from PIL import Image, ImageDraw, ImageFont
from typing import List
import asyncio
from io import BytesIO
from aiohttp import ClientSession
from cocotst.app import Cocotst
from cocotst.event.message import GroupMessage, C2CMessage
from cocotst.network.model.target import Target
from cocotst.message.parser.base import QCommandMatcher
from cocotst.message.element import Image as MessageImage
from graia.saya.builtins.broadcast.shortcut import listen, decorate
from kayaku import create
from config_model.qapi import QOpenAPI
from database.model import User
from datetime import datetime
import os
from pathlib import Path

QOPENID = create(QOpenAPI).AppID
CACHE_DIR = "cache"
CACHE_DURATION = 30 * 60  # 30分钟，以秒为单位


def get_cache_path() -> str:
    """获取最新的缓存文件路径"""
    if not os.path.exists(CACHE_DIR):
        return None
        
    cache_files = [f for f in os.listdir(CACHE_DIR) if f.startswith("rank-") and f.endswith(".png")]
    if not cache_files:
        return None
        
    return os.path.join(CACHE_DIR, sorted(cache_files)[-1])

async def should_update_cache() -> bool:
    """检查是否需要更新缓存"""
    cache_path = get_cache_path()
    if not cache_path:
        return True
        
    try:
        # 从文件名中提取时间戳
        timestamp = int(cache_path.split("-")[1].split(".")[0])
        time_diff = datetime.now().timestamp() - timestamp
        return time_diff > CACHE_DURATION
    except (ValueError, IndexError):
        return True

async def generate_rank_image(users: List[User]) -> bytes:
    # 检查缓存
    if not await should_update_cache():
        cache_path = get_cache_path()
        if cache_path:
            try:
                with open(cache_path, 'rb') as f:
                    return f.read()
            except Exception as e:
                print(f"读取缓存出错: {e}")
                # 如果读取缓存出错，继续生成新图片
    
    # 加载背景图片
    background = Image.open("resource/signin/rank.png")
    draw = ImageDraw.Draw(background)
    
    # 使用更新后的字体路径
    font_path = "resource/font/sarasa-mono-sc-semibold.ttf"
    title_font = ImageFont.truetype(font_path, 42)
    rank_font = ImageFont.truetype(font_path, 32)
    name_font = ImageFont.truetype(font_path, 28)
    
    # 绘制标题
    draw.text((360, 50), "签到排行榜", font=title_font, fill="#FFFFFF", anchor="mm")
    
    # 绘制排行内容
    start_y = 140
    spacing = 120  # 增加间距使布局更宽松
    avatar_size = 70  # 减小头像尺寸
    
    for idx, user in enumerate(users[:9]):
        y_pos = start_y + idx * spacing
        
        # 获取用户头像
        async with ClientSession() as session:
            async with session.get(f"https://q.qlogo.cn/qqapp/{QOPENID}/{user.uid}/100") as resp:
                avatar_data = await resp.read()
                
        # 处理头像
        with BytesIO(avatar_data) as bio:
            avatar = Image.open(bio).convert('RGBA')
            avatar = avatar.resize((avatar_size, avatar_size))
            
            # 创建圆形蒙版
            mask = Image.new('L', (avatar_size, avatar_size), 0)
            mask_draw = ImageDraw.Draw(mask)
            mask_draw.ellipse((0, 0, avatar_size, avatar_size), fill=255)
            
            # 应用圆形蒙版
            output = Image.new('RGBA', (avatar_size, avatar_size), (0, 0, 0, 0))
            output.paste(avatar, (0, 0))
            output.putalpha(mask)
            
            # 将头像粘贴到背景上
            background.paste(output, (90, y_pos), output)
        
        # 绘制排名符号
        rank_num = f"#{idx + 1}"
        draw.text((40, y_pos + avatar_size//2), rank_num, font=rank_font, fill="#FFFFFF", anchor="rm")
        
        # 绘制用户名和数据
        name_text = user.name
        if idx == 0:  # 第一名添加特殊标识
            name_text += " <小霖之星>"
            
        name_x = 180  # 增加文字起始位置
        draw.text((name_x, y_pos + 15), name_text, font=name_font, fill="#FFFFFF", anchor="lm")
        draw.text((name_x, y_pos + avatar_size - 10), 
                 f"签到 {user.signed_days} 天 | 好感度 {user.favorability}", 
                 font=name_font, fill="#FFFFFF", anchor="lm")
    draw.text((360, start_y + spacing * 9 + 40), "Generated By 小霖念Plus", font=name_font, fill="#FFFFFF", anchor="mm")
    # 确保缓存目录存在
    os.makedirs(CACHE_DIR, exist_ok=True)
    
    # 生成新的缓存文件名（使用时间戳）
    timestamp = int(datetime.now().timestamp())
    cache_path = os.path.join(CACHE_DIR, f"rank-{timestamp}.png")
    
    # 保存到缓存文件
    output = BytesIO()
    background.save(output, format='PNG')
    image_data = output.getvalue()
    
    # 写入新缓存
    try:
        with open(cache_path, 'wb') as f:
            f.write(image_data)
            
        # 清理旧的缓存文件
        for old_file in os.listdir(CACHE_DIR):
            if old_file.startswith("rank-") and old_file.endswith(".png") and old_file != os.path.basename(cache_path):
                try:
                    os.remove(os.path.join(CACHE_DIR, old_file))
                except Exception as e:
                    print(f"删除旧缓存文件出错: {e}")
    except Exception as e:
        print(f"写入缓存出错: {e}")
    
    return image_data

@listen(GroupMessage)
@decorate(QCommandMatcher("排行榜"))
async def rank_handler(app: Cocotst, target: Target):
    # 获取所有用户并按好感度排序
    users = await User.find_all().sort(-User.favorability).to_list()
    
    # 生成排行榜图片
    result = await generate_rank_image(users)
    
    # 发送消息
    await app.send_group_message(
        target,
        content="✨ 这是当前的签到排行榜",
        element=MessageImage(data=result),
    )

@listen(C2CMessage)
@decorate(QCommandMatcher("排行榜"))
async def rank_handler_c2c(app: Cocotst, target: Target):
    # 获取所有用户并按好感度排序
    users = await User.find_all().sort(-User.favorability).to_list()
    
    # 生成排行榜图片
    result = await generate_rank_image(users)
    
    # 发送消息
    await app.send_c2c_message(
        target,
        content="✨ 这是当前的签到排行榜",
        element=MessageImage(data=result),
    )